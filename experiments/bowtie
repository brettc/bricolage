#!env python
"""
Generate and analyse bowtie networks.

While running press 'g' to generate a network graph.

Usage:
  bowtie run <name> <function> [--replicate=<N>] [--overwrite] [--data=<data>] [--output=<output>]
  bowtie run_all <name> [--overwrite] [--data=<data>] [--output=<output>]
  bowtie draw <name> <function> [--draw_n=<N>] [--overwrite] [--data=<data>] [--output=<output>]
  bowtie speed_all <name> [--data=<data>] [--output=<output>]
  bowtie finalinfo_all <name> [--data=<data>] [--output=<output>]
  bowtie meaninfo <name> <function> [--replicate=<N>] [--data=<data>] [--output=<output>]
  bowtie list_experiments
  bowtie list_functions
  bowtie -h | --help 
  bowtie --version

Options:
  --replicate=<N>   Only run/analyse replicate <N>.
  --function=<fn>   Only run/analyse function number <n>.
  --draw_n=<N>      Draw this many graphs per lineage [default: 3].
  --data=<data>     Where data is written to and read from [default: ~/Desktop].
  --output=<output> Where output from analyses are written. 
                    [default: ~/Dropbox/SimulationOutput].
  --overwrite       Kill anything that is there and start again.
  -h --help         Show this screen.
"""

__version__ = '0.0.1'


from docopt import docopt
import sys
import pathlib
import yaml
from getch import getch, kbhit

import numpy as np
import pandas as pd

HERE_DIR = pathlib.Path(__file__).parent.absolute()
PARENT_DIR = HERE_DIR.parent
sys.path.append(str(PARENT_DIR))

from bricolage import threshold3, lineage, graph
from boolean_functions import get_functions
from bricolage.analysis_ext import (MutualInfoAnalyzer,
                                    CausalFlowAnalyzer, Information)
from bricolage.analysis import LineageSummarizer

from utils import Arguments, command, log, ProgramError, make_path

class BowtieError(Exception):
    pass

outputs = {
    'complex3': [1, .5, .25],
    'simple3': [0, 1, 1],
}

def make_target_single_output(oldf):
    def new_f(a, b, c):
        if oldf(a, b, c):
            return [0]
        return [1]
    return new_f

def make_target_simple(oldf):
    def new_f(a, b, c):
        if oldf(a, b, c):
            return [0, 1, 1]
        return [1, 0, 0]
    return new_f

def make_target_function_3(oldf):
    def new_f(a, b, c):
        if oldf(a, b, c):
            return [1, .5, .25]
        return [0, 0, 0]
    return new_f

def make_target_function_4(oldf):
    def new_f(a, b, c, d):
        if oldf(a, b, c):
            if d:
                return [1, 1, 1]
            return [.5, .5, .5]
        return [0, 0, 0]
    return new_f

def make_target_function_5(oldf):
    def new_f(a, b, c, d, e):
        r1 = 0.0
        r2 = 0.0
        if oldf(a, b, c):
            if d:
                r1 = .5
            else:
                r1 = .25
            if e:
                r2 = 1.0
            else:
                r2 = .5
        return [r1, r2]
    return new_f

def draw_net(rep, prefix, net, gen):
        ana = threshold3.NetworkAnalysis(net)
        g = graph.FullGraph(ana)#, knockouts=False)
        d = graph.DotMaker(g)
        p = rep.analysis_path / '{}-G{:07d}-N{:02d}-F{}.png'.format(
            prefix, gen, net.identifier, net.fitness)
        log.info("writing {}".format(str(p)))
        d.save_picture(str(p))
        d.save_dot(str(p.with_suffix('.dot')))

def draw_top(rep, maxn):
    with rep.get_lineage() as lin:
        winners = [(n.fitness, n) for n in lin.population]
        winners.sort(reverse=True)

        for i, (fit, net) in enumerate(winners):
            if i == maxn:
                break
            draw_net(rep, 'winner', net, lin.generation)

def callback_draw(replicate, draw_n):
    the_lineage = replicate.get_lineage()
    log.info('---> draw: %s', replicate.path)
    draw_top(replicate, draw_n)
    the_lineage.close()
    log.info('---> end: %s', replicate.path)
    
def get_yaml():
    with open(str(HERE_DIR / 'bowtie.yaml'), 'r') as f:
        return yaml.load(f)

def get_parameters(args):
    """Load parameters from the yaml file"""
    name = args.arguments.name
    try:
        param_args = get_yaml()[name]
    except KeyError:
        log.error("{} was not found in bowtie.yaml".format(name))
        raise ProgramError

    p = threshold3.Parameters(**param_args)
    p.name = name
    return p

def keyboard_check(replicate, the_lineage):
    if kbhit():
        c = getch().lower()
        if c == 'g':
            log.info("--> Making a graph")
            draw_top(replicate, 1)
        # elif c == 's':
        #     the_lineage.save_snapshot()

def make_name(desc, N):
    desc = desc.replace(' ', '-')
    name = "{:02d}-{}".format(N, desc)
    return name

def get_name(N):
    desc, boolean_func = get_functions()[N]
    return make_name(desc, N)

def get_name_and_target(args, params):
    N = args.arguments.function
    desc, boolean_func = get_functions()[N]
    name = make_name(desc, N)

    log.info('getting target %s', params.target)
    try:
        make_target = globals()['make_target_%s' % params.target]
    except:
        log.error("Invalid target given")
        raise ProgramError

    target_func = make_target(boolean_func)

    return name, target_func

def run_replicate(replicate, target_func, max_gen):
    the_lineage = replicate.get_lineage()
    if replicate.fresh:
        the_lineage.add_target(target_func)
    assert len(the_lineage.targets) == 1

    log.info('---> begin: %s', replicate.path)
    while the_lineage.generation < max_gen:
        the_lineage.next_generation()
        minf, maxf = the_lineage.population.worst_and_best()
        if the_lineage.generation % 100 == 0:
            log.info("\t%s, %s", the_lineage.generation, maxf)
        keyboard_check(replicate, the_lineage)

    draw_top(replicate, 3)
    the_lineage.close()
    # When we're done, draw
    log.info('---> end: %s', replicate.path)

@command
def list_experiments(arguments):
    y = get_yaml()
    log.info("Here are available experiments ...")
    for k in y.keys():
        log.info("\t - {}".format(k))

@command
def list_functions(arguments):
    log.info("The boolean functions are ....")
    for i, f in enumerate(get_functions()):
        log.info("{:02d} -- {}".format(i, f[0]))

@command
def run(arguments):
    """Do the experiment"""
    params=get_parameters(arguments)
    name, target_func = get_name_and_target(arguments, params)
    treat = lineage.Treatment(
        arguments['data_dir'] / name, 
        analysis_path = arguments['output_dir'] / name,
        params=params,
        overwrite=arguments['--overwrite']
    )

    if arguments['--replicate']:
        rep_num = int(arguments['--replicate'])
        if not 0 < rep_num < len(treat.replicates):
            log.error("Replicate number not good")
            raise ProgramError
        log.info("Running one replicate {}".format(rep_num))
        run_replicate(treat.replicates[rep_num], target_func, params.max_generations)
    else:
        log.info("Running all replicates ...")
        for rep in treat.iter_replicates():
            run_replicate(rep, target_func, params.max_generations)
            draw_top(rep, 3)

@command
def run_all(arguments):
    for i in range(len(get_functions())):
        arguments['<function>'] = str(i)
        run(arguments)

@command
def draw(arguments):
    params=get_parameters(arguments)
    name, target_func = get_name_and_target(arguments, params)
    treat = lineage.Treatment(
        arguments['data_dir'] / name, 
        analysis_path = arguments['output_dir'] / name,
    )
    treat.run(callback_draw, draw_n=int(arguments['--draw_n']))

def all_existing(arguments):
    for i in range(len(get_functions())):
        name = get_name(i)
        try:
            treat = lineage.Treatment(
                arguments.options.data_dir / name, 
                analysis_path = arguments.options.output_dir / name,
                readonly = True,
            )
        except lineage.LineageError:
            continue

        for rep in treat.replicates:
            try:
                with rep.get_lineage(readonly=True) as lin:
                    yield i, name, treat, rep, lin
            except lineage.LineageError:
                # Ignore stuff that hasn't been created
                pass

@command
def finalinfo_all(args):
    # This flattens everything out
    treats = []
    reps = []
    func_number = []
    signals = []
    fits = []

    for fno, name, treat, rep, lin in all_existing(arguments):
        # Construct the analyzers
        a_flow = CausalFlowAnalyzer(lin.world, [0, .5, .25])
        p_flow = a_flow.analyse_collection(lin.population)
        flow = Information(p_flow)
        mean_info = np.asarray(flow).max(axis=0).ravel()
        max_info = mean_info.max()
        w, b = lin.population.worst_and_best()

        log.info("Doing T{}, R{}, info {}, fit {}".format(name, rep, max_info, b))

        signals.append(max_info)
        fits.append(b)
        treats.append(name)
        func_number.append(fno)
        reps.append(rep.sequence)

    data=dict(
        treatment=treats,
        function=func_number,
        replicate=reps,
        max_info=signals,
        max_fitness=fits,
    )
    # signals = np.array(signals).T
    # for i in range(lin.world.reg_channels):
        # data['S{}'.format(i+1)] = signals[i]

    df = pd.DataFrame(data)
    df.to_pickle(str(arguments['output_dir'] / 'signals.pickle'))

@command
def speed_all(arguments):
    # This flattens everything out
    gens = []
    treats = []
    reps = []
    func_number = []

    for fno, name, treat, rep, lin in all_existing(arguments):
        # Where did we find the first 1.0
        fits = lin._generations[:]['best']
        best = np.isclose(fits, 1.0)
        if np.any(best):
            gen = np.argmax(best)
            pop_g = lin.get_generation(gen)
            for net in pop_g:
                if np.isclose(net.fitness, 1.0):
                    draw_net(rep, 'first', net,  lin.generation)
        else:
            gen = None

        log.info('{}, rep {}, first found 1.0 at {} generation'.format(
            name, rep.sequence, gen))
        treats.append(name)
        func_number.append(fno)
        reps.append(rep.sequence)
        gens.append(gen)

    df = pd.DataFrame(data=dict(
        treatment=treats,
        function=func_number,
        replicate=reps,
        generations=gens,
    ))
    df.to_pickle(str(arguments['output_dir'] / 'speed.pickle'))


def calc_info(params, rep, lin):
    targ = lin.targets[0]
    flow = outputs[params.flow_test]
    lineage_sum = LineageSummarizer(lin, targ, flow)

    for i, g in lineage_sum.calc_generations():
        print rep, i, g

    df = lineage_sum.get_frame()
    p = rep.analysis_path / 'lineage.pickle'
    log.info('saving %s', str(p))
    df.to_pickle(str(p))

@command
def meaninfo(args):
    params = get_parameters(args)
    name, target_func = get_name_and_target(args, params)
    treat = lineage.Treatment(
        args.options.data_dir / name, 
        analysis_path=args.options.output_dir / name,
        params=params,
    )
    for rep in treat.replicates:
        with rep.get_lineage() as lin:
            calc_info(params, rep, lin)


class MyArguments(Arguments):
    def pre_run(self):
        """Translate the folder names into paths"""
        if self.arguments.function is not None:
            self.arguments.function = int(self.arguments.function)

        if self.options.data is None \
                or self.options.output is None \
                or self.arguments.name is None:
            return 

        data_base =  make_path(self.options.data)
        output_base =  make_path(self.options.output)

        for d in (data_base, output_base):
            if not d.exists():
                log.error("The folder '{}' doesn't exist".format(str(data_base)))
                raise ProgramError

        data_dir = data_base  / self.arguments.name
        output_dir = output_base / self.arguments.name

        for d in (data_dir, output_dir):
            if not d.exists():
                log.info("Making folder {} ...".format(str(d)))
                d.mkdir()

        self.options.data_dir = data_dir 
        self.options.output_dir = output_dir 
        

if __name__ == "__main__":
    arguments = MyArguments(docopt(__doc__, version=__version__))
    sys.exit(arguments.run())
