#!env python
"""
Generate and analyse bowtie networks

Usage:
  bowtie run <name> <function> [--overwrite] [--data=<data>] [--output=<output>]
  bowtie runall <name> [--overwrite] [--data=<data>] [--output=<output>]
  bowtie list
  bowtie functions
  bowtie -h | --help 
  bowtie --version

Options:
  --function=<fn>   Only run/analyse function number <n>
  --data=<data>     Where data is written [default: ~/Desktop]
  --output=<output> Write output from analysis here 
                    [default: ~/Dropbox/SimulationOutput]
  --overwrite       Kill anything that is there and start again
  -h --help         Show this screen.
"""

__version__ = '0.0.1'

import logging
logging.basicConfig(
    format="%(levelname)-8s | %(message)s",
    level=logging.INFO,
    # datefmt="%H:%M:%S"
)
log = logging.getLogger("")

from docopt import docopt
import sys
import pathlib, os
import yaml
from getch import getch, kbhit

here_dir = pathlib.Path(__file__).parent.absolute()
parent_dir = here_dir.parent
sys.path.append(str(parent_dir))

from bricolage import threshold3, lineage, graph
from boolean_functions import get_functions
# from bricolage.core_ext import InfoE
# import pandas as pd
#
class BowtieError(Exception):
    pass

def make_target_function(oldf):
    def new_f(a, b, c):
        if oldf(a, b, c):
            return [1, .5, .25]
        return [0, 0, 0]
    return new_f

def draw_top(rep, lin, maxn):
    winners = [(n.fitness, n) for n in lin.population]
    winners.sort(reverse=True)

    for i, (fit, net) in enumerate(winners):
        ana = threshold3.NetworkAnalysis(net)
        g = graph.FullGraph(ana)#, knockouts=False)
        d = graph.DotMaker(g)
        p = str(rep.analysis_path / './net-G{:07d}-N{:02d}-F{}.png'.format(lin.generation, net.identifier, fit))
        log.info("writing {}".format(p))
        d.save_picture(p)
        if i + 1 == maxn:
            break
    
def get_yaml():
    with open(str(here_dir / 'bowtie.yaml'), 'r') as f:
        return yaml.load(f)

def get_parameters(arguments):
    """Load parameters from the yaml file"""
    name = arguments['<name>']
    try:
        param_args = get_yaml()[name]
    except KeyError:
        log.error("{} was not found in bowtie.yaml".format(name))
        raise BowtieError

    return threshold3.Parameters(**param_args)

def callback_run(replicate, target_func):
    the_lineage = replicate.get_lineage()
    if replicate.fresh:
        the_lineage.add_target(target_func)
    else:
        # TODO: check that this target is the same
        # validate somehow
        pass

    log.info('---> begin: %s', replicate.path)

    max_gen = replicate.treatment.params.max_generations
    while the_lineage.generation < max_gen:
        the_lineage.next_generation()
        minf, maxf = the_lineage.population.worst_and_best()
        if the_lineage.generation % 100 == 0:
            log.info("\t%s, %s", the_lineage.generation, maxf)
        keyboard_check(replicate, the_lineage)

    the_lineage.close()
    # When we're done, draw
    # _draw(replicate, the_lineage, 5)
    log.info('---> end: %s', replicate.path)

def keyboard_check(replicate, the_lineage):
    if kbhit():
        c = getch().lower()
        if c == 'g':
            log.info("--> Making a graph")
            draw_top(replicate, the_lineage, 1)
        # elif c == 's':
        #     the_lineage.save_snapshot()

def make_path(pathname):
    # The backported version of pathlib doesn't have expanduser!!
    return pathlib.Path(os.path.expanduser(pathname)).absolute()

def check_folders(arguments):
    data_base = make_path(arguments['--data'])
    output_base = make_path(arguments['--output'])
    for d in (data_base, output_base):
        if not d.exists():
            log.error("The folder '{}' doesn't exist".format(str(data_base)))
            raise BowtieError
    
    data_dir = data_base  / arguments['<name>']
    output_dir = output_base / arguments['<name>']
    for d in (data_dir, output_dir):
        if not d.exists():
            log.info("Making folder {} ...".format(str(data_dir)))
            d.mkdir()

    arguments['data_dir'] = data_dir 
    arguments['output_dir'] = output_dir 

def do_list(arguments):
    y = get_yaml()
    log.info("Here are available experiments ...")
    for k in y.keys():
        log.info("\t - {}".format(k))

def do_functions():
    log.info("The boolean functions are ....")
    for i, f in enumerate(get_functions()):
        log.info("{:02d} -- {}".format(i, f[0]))

def do_run(arguments):
    """Do the experiment"""

    N = int(arguments['<function>'])
    desc, boolean_func = get_functions()[N]
    desc = desc.replace(' ', '-')
    name = "{:02d}-{}".format(N, desc)
    target_func = make_target_function(boolean_func)

    treat = lineage.Treatment(
        arguments['data_dir'] / name, 
        analysis_path = arguments['output_dir'] / name,
        params=get_parameters(arguments), 
        overwrite=arguments['--overwrite']
    )
    treat.run(callback_run, target_func=target_func)

def main(arguments):
    try:
        if arguments['functions']:
            do_functions()
        elif arguments['run']:
            check_folders(arguments)
            do_run(arguments)
        elif arguments['list']:
            do_list(arguments)
    except BowtieError:
        log.error("Error: exiting program...")
        return 1
    except:
        raise
    return 0

if __name__ == "__main__":
    arguments = docopt(__doc__, version=__version__)
    sys.exit(main(arguments))
