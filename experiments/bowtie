#!env python
"""
Generate and analyse bowtie networks

Usage:
  bowtie run <name> <function> [--overwrite] [--data=<data>] [--output=<output>]
  bowtie run_all <name> [--overwrite] [--data=<data>] [--output=<output>]
  bowtie draw <name> <function> [--draw_n=<N>] [--overwrite] [--data=<data>] [--output=<output>]
  bowtie speed_all <name> [--data=<data>] [--output=<output>]
  bowtie list
  bowtie functions
  bowtie -h | --help 
  bowtie --version

Options:
  --function=<fn>   Only run/analyse function number <n>.
  --draw_n=<N>      Draw this many graphs per lineage [default: 3].
  --data=<data>     Where data is written to and read from [default: ~/Desktop].
  --output=<output> Where output from analyses are written. 
                    [default: ~/Dropbox/SimulationOutput].
  --overwrite       Kill anything that is there and start again.
  -h --help         Show this screen.
"""

__version__ = '0.0.1'

import logging
logging.basicConfig(
    format="%(levelname)-8s | %(message)s",
    level=logging.INFO,
    # datefmt="%H:%M:%S"
)
log = logging.getLogger("")

from docopt import docopt
import sys
import pathlib, os
import yaml
from getch import getch, kbhit

import numpy as np
import pandas as pd

here_dir = pathlib.Path(__file__).parent.absolute()
parent_dir = here_dir.parent
sys.path.append(str(parent_dir))

from bricolage import threshold3, lineage, graph
from boolean_functions import get_functions
# from bricolage.core_ext import InfoE
#
class BowtieError(Exception):
    pass

def make_target_single_output(oldf):
    def new_f(a, b, c):
        if oldf(a, b, c):
            return [0]
        return [1]
    return new_f

def make_target_simple(oldf):
    def new_f(a, b, c):
        if oldf(a, b, c):
            return [0, 1, 1]
        return [1, 0, 0]
    return new_f

def make_target_function_3(oldf):
    def new_f(a, b, c):
        if oldf(a, b, c):
            return [1, .5, .25]
        return [0, 0, 0]
    return new_f

def make_target_function_4(oldf):
    def new_f(a, b, c, d):
        if oldf(a, b, c):
            if d:
                return [1, 1, 1]
            return [.5, .5, .5]
        return [0, 0, 0]
    return new_f

def make_target_function_5(oldf):
    def new_f(a, b, c, d, e):
        r1 = 0.0
        r2 = 0.0
        if oldf(a, b, c):
            if d:
                r1 = .5
            else:
                r1 = .25
            if e:
                r2 = 1.0
            else:
                r2 = .5
        return [r1, r2]
    return new_f


def draw_net(rep, prefix, net, gen):
        ana = threshold3.NetworkAnalysis(net)
        g = graph.FullGraph(ana)#, knockouts=False)
        d = graph.DotMaker(g)
        p = str(rep.analysis_path / '{}-G{:07d}-N{:02d}-F{}.png'.format(
            prefix, gen, net.identifier, net.fitness))
        log.info("writing {}".format(p))
        d.save_picture(p)


def draw_top(rep, lin, maxn):
    winners = [(n.fitness, n) for n in lin.population]
    winners.sort(reverse=True)

    for i, (fit, net) in enumerate(winners):
        if i == maxn:
            break
        draw_net(rep, 'winner', net, lin.generation)

def callback_draw(replicate, draw_n):
    the_lineage = replicate.get_lineage()
    log.info('---> draw: %s', replicate.path)
    draw_top(replicate, the_lineage, draw_n)
    the_lineage.close()
    log.info('---> end: %s', replicate.path)
    
def get_yaml():
    with open(str(here_dir / 'bowtie.yaml'), 'r') as f:
        return yaml.load(f)

def get_parameters(arguments):
    """Load parameters from the yaml file"""
    name = arguments['<name>']
    try:
        param_args = get_yaml()[name]
    except KeyError:
        log.error("{} was not found in bowtie.yaml".format(name))
        raise BowtieError

    p = threshold3.Parameters(**param_args)
    p.name = name
    return p

def callback_run(replicate, target_func, max_gen):
    the_lineage = replicate.get_lineage()
    if replicate.fresh:
        the_lineage.add_target(target_func)
    else:
        # TODO: check that this target is the same
        # validate somehow
        pass

    log.info('---> begin: %s', replicate.path)
    while the_lineage.generation < max_gen:
        the_lineage.next_generation()
        minf, maxf = the_lineage.population.worst_and_best()
        if the_lineage.generation % 100 == 0:
            log.info("\t%s, %s", the_lineage.generation, maxf)
        keyboard_check(replicate, the_lineage)

    draw_top(replicate, the_lineage, 3)
    the_lineage.close()
    # When we're done, draw
    log.info('---> end: %s', replicate.path)

def keyboard_check(replicate, the_lineage):
    if kbhit():
        c = getch().lower()
        if c == 'g':
            log.info("--> Making a graph")
            draw_top(replicate, the_lineage, 1)
        # elif c == 's':
        #     the_lineage.save_snapshot()

def make_path(pathname):
    # The backported version of pathlib doesn't have expanduser!!
    return pathlib.Path(os.path.expanduser(pathname)).absolute()

def check_folders(arguments):
    data_base = make_path(arguments['--data'])
    output_base = make_path(arguments['--output'])
    for d in (data_base, output_base):
        if not d.exists():
            log.error("The folder '{}' doesn't exist".format(str(data_base)))
            raise BowtieError
    
    data_dir = data_base  / arguments['<name>']
    output_dir = output_base / arguments['<name>']
    for d in (data_dir, output_dir):
        if not d.exists():
            log.info("Making folder {} ...".format(str(data_dir)))
            d.mkdir()

    arguments['data_dir'] = data_dir 
    arguments['output_dir'] = output_dir 

def do_list(arguments):
    y = get_yaml()
    log.info("Here are available experiments ...")
    for k in y.keys():
        log.info("\t - {}".format(k))

def do_functions():
    log.info("The boolean functions are ....")
    for i, f in enumerate(get_functions()):
        log.info("{:02d} -- {}".format(i, f[0]))

def make_name(desc, N):
    desc = desc.replace(' ', '-')
    name = "{:02d}-{}".format(N, desc)
    return name

def get_name(N):
    desc, boolean_func = get_functions()[N]
    return make_name(desc, N)

def get_name_and_target(arguments, params):
    N = int(arguments['<function>'])
    desc, boolean_func = get_functions()[N]
    name = make_name(desc, N)

    log.info('getting target %s', params.target)
    try:
        make_target = globals()['make_target_%s' % params.target]
    except:
        log.error("Invalid target given")
        raise BowtieError

    target_func = make_target(boolean_func)

    return name, target_func

def do_run(arguments):
    """Do the experiment"""
    params=get_parameters(arguments)
    name, target_func = get_name_and_target(arguments, params)
    treat = lineage.Treatment(
        arguments['data_dir'] / name, 
        analysis_path = arguments['output_dir'] / name,
        params=params,
        overwrite=arguments['--overwrite']
    )
    treat.run(callback_run, target_func=target_func, max_gen=params.max_generations)

def do_run_all(arguments):
    for i in range(len(get_functions())):
        arguments['<function>'] = str(i)
        do_run(arguments)

def do_draw(arguments):
    name, target_func = get_name_and_target(arguments)
    treat = lineage.Treatment(
        arguments['data_dir'] / name, 
        analysis_path = arguments['output_dir'] / name,
    )
    treat.run(callback_draw, draw_n=int(arguments['--draw_n']))


def all_existing(arguments):
    for i in range(len(get_functions())):
        name = get_name(i)
        try:
            treat = lineage.Treatment(
                arguments['data_dir'] / name, 
                analysis_path = arguments['output_dir'] / name,
                readonly = True,
            )
        except lineage.LineageError:
            continue

        for rep in treat.replicates:
            try:
                with rep.get_lineage(readonly=True) as lin:
                    yield treat, rep, lin
            except lineage.LineageError:
                # Ignore stuff that hasn't been created
                pass


def do_speed_all(arguments):
    # This flattens everything out
    gens = []
    treats = []
    reps = []

    for treat, rep, lin in all_existing(arguments):
        # Where did we find the first 1.0
        fits = lin._generations[:]['best']
        best = np.isclose(fits, 1.0) #np.ones(len(fits)))
        if np.any(best):
            gen = np.argmax(best)
            pop_g = lin.get_generation(gen)
            for net in pop_g:
                if np.isclose(net.fitness, 1.0):
                    draw_net(rep, 'first', net,  lin.generation)
        else:
            gen = None

        log.info('first found 1.0 at {} generation'.format(gen))
        treats.append(treat.name)
        reps.append(rep.sequence)
        gens.append(gen)

    df = pd.DataFrame(data=dict(
        treatment=treats,
        replicate=reps,
        generations=gens,
    ))
    df.to_pickle(str(arguments['output_dir'] / 'speed.pickle'))

def main(arguments):
    try:
        check_folders(arguments)
        if arguments['functions']:
            do_functions()
        elif arguments['run']:
            do_run(arguments)
        elif arguments['run_all']:
            do_run_all(arguments)
        elif arguments['draw']:
            do_draw(arguments)
        elif arguments['list']:
            do_list(arguments)
        elif arguments['speed_all']:
            do_speed_all(arguments)

    except BowtieError:
        # These are the errors that we generate!
        log.error("Error: exiting program...")
        return 1

    # TODO: Handle UserBreak?
    except:
        raise
    return 0

if __name__ == "__main__":
    arguments = docopt(__doc__, version=__version__)
    sys.exit(main(arguments))
