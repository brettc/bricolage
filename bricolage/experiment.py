import logging
log = logging.getLogger("experiment")

import copy
import cPickle as pickle
# import shutil
import random

from pathlib import Path
from lineage import FullLineage, SnapshotLineage

class ExperimentError(RuntimeError):
    pass


def _ensure_path(path, name):
    if not isinstance(path, Path):
        path = Path(path)

    if not path.exists():
        log.error("No parent path: {}".format(str(path)))
        raise ExperimentError

    path = path / name

    if not path.exists():
        log.info("Creating path {}".format(str(path)))
        path.mkdir()

    return path


class Replicate(object):
    """Wraps a lineage into a sub-folder"""

    FILENAME = 'lineage.h5'

    def __init__(self, treatment, seq):
        self.treatment = treatment
        self.seq = seq
        self.seed = treatment.rng.randint(0, 1 << 16)
        self.fresh = True
        self.params = copy.deepcopy(self.treatment.params)
        self.params.seed = self.seed

    def run(self):
        if not self.path.exists():
            self.path.mkdir()
        with self.get_lineage() as lin:
            self.treatment.run_replicate(self, lin)

    @property
    def dirname(self):
        return "{:03d}".format(self.seq)

    @property
    def path(self):
        return self.treatment.path / self.dirname

    @property
    def analysis_path(self):
        return self.treatment.analysis_path / self.dirname

    @property
    def lineage_name(self):
        return self.path / self.FILENAME

    def has_started(self):
        return self.lineage_name.exists()

    def get_lineage(self, readonly=False):
        p = self.path
        if not p.exists():
            if readonly:
                log.error("Replicate doesn't exist, {}".format(self.name))
                raise ExperimentError

            p.mkdir()

        # We don't use this, but users of the class might depend on it
        if not self.analysis_path.exists():
            self.analysis_path.mkdir()

        db_path = self.lineage_name

        # Load the lineage
        if db_path.exists():
            lin = self.treatment.experiment.lineage_class(
                db_path, readonly=readonly)

            # If we reloaded then the seed should be the same as what was
            # generated by the original parameters
            if not lin.params.same_as(self.params):
                log.error("Parameters have changed!")
                raise ExperimentError

            log.info("Loaded lineage {}".format(lin))

            # Kill this flag
            self.fresh = False

        if self.fresh:
            lin = self.treatment.experiment.lineage_class(db_path, self.params)
            log.info("Created lineage {}".format(lin))

        return lin


class Treatment(object):
    """Replicate a set of experiments into different folders"""

    def __init__(self, experiment, name, params, count):
        self.experiment = experiment
        self.name = name
        self.params = params
        self.seq = experiment.get_next_treatment_seq()
        self.seed = experiment.rng.randint(0, 1 << 16)
        self.rng = random.Random(self.seed)
        self.count = count
        self.replicates = [Replicate(self, i) for i in range(1, count + 1)]

        self.experiment.treatments.append(self)

    @property
    def dirname(self):
        return "{0.seq:02d}_{0.name}".format(self)

    @property
    def path(self):
        return self.experiment.path / self.dirname

    @property
    def analysis_path(self):
        return self.experiment.analysis_path / self.dirname

    def run(self):
        if not self.path.exists():
            self.path.mkdir()
        if not self.analysis_path.exists():
            self.analysis_path.mkdir()
        for r in self.replicates:
            r.run()


class Experiment(object):
    def __init__(self, path, name, seed, analysis_path=None, full=True):
        self.path = _ensure_path(path, name)
        if analysis_path:
            self.analysis_path = _ensure_path(analysis_path, name)
        else:
            self.analysis_path = self.path

        self.next_treatment_seq = 0
        self.treatments = []

        if full:
            self.lineage_class = FullLineage
        else:
            self.lineage_class = SnapshotLineage

        self.seed = seed
        self.rng = random.Random(seed)

    def get_next_treatment_seq(self):
        self.next_treatment_seq += 1
        return self.next_treatment_seq

    def run(self):
        for treat in self.treatments:
            treat.run()



    
